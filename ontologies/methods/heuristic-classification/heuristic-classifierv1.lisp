;;; -*- Mode: LISP; Syntax: Common-lisp; Base: 10; Package: OCML; -*- 

;;;; HEURISTIC-CLASSIFICATION :METHOD ;;;;

(in-package "OCML")

(in-ontology heuristic-classification)


;;;THE-VIRTUAL-SOLUTION-SPACE
(def-function the-virtual-solution-space (?init-space ?refs) -> ?solution-space
  "The space generated by refinement application from an initial solution space"
  :constraint (and (every ?refs refiner)
                   (solution-space ?init-space))
  :def (= ?solution-space
          (setofall ?sol2 (or (member ?sol2 ?init-space)
                              (exists (?ref ?sol3)
                                      (and (member ?ref ?refs)
                                           (member ?sol2 (apply-refiner-operator 
                                                          ?ref ?sol3))
                                           (member ?sol3 ?solution-space)))))))


;;;HEURISTIC-SINGLE-SOL-CLASSIFIER
(def-class heuristic-single-sol-classifier (problem-solving-method) ?psm
  
  ((has-input-role :value has-abstractors
                   :value has-refiners
                   :value has-observables
                   :value has-candidate-solutions
                   )
   (has-control-role :value 'has-current-solutions)
   (has-output-role :value has-solution)
   (has-current-solutions :type solution-space)
   (has-abstractors :type abstractors)
   (has-refiners :type refiners)
    (has-observables :type observables)
    (has-candidate-solutions :type solution-space)
   (has-solution :type solution)
   (has-precondition 
    :value (kappa (?psm)
                  (every (role-value ?psm 'has-candidate-solutions)
                         (kappa (?sol)
                                (not (exists 
                                      (?ref ?sol2)
                                      (and (member ?ref (role-value 
                                                         ?psm 'has-refiners))
                                           (member ?sol2 
                                                   (role-value 
                                                    ?psm 'has-candidate-solutions))
                                           (member ?sol (apply-refiner-operator 
                                                         ?ref ?sol2))))))))
    :documentation "Each input solution is assumed to be a 'top solution' -
                    i.e., one which has not been refined through refinement application
                    from other elements of the solution space")
   (has-postcondition 
    :value (kappa (?psm ?sol)
                  (admissible-solution 
                   ?sol 
                   (apply-match-criterion 
                    (role-value ?psm 'has-match-criterion)
                    (role-value ?psm 'has-observables)
                    ?sol)
                   (role-value 
                    ?psm 
                    'has-solution-admissibility-criterion)))
    :documentation "The output solution satisfies the admissibility criterion")
   
   (has-body 
    :value '(lambda (?psm)
              (in-environment                                              
               ((?obs . (achieve-generic-subtask 
                         ?psm abstraction
                         'has-observables (role-value ?psm has-observables)
                         'has-abstractors (role-value ?psm has-abstractors))))
               (do
                 (set-role-value ?psm 'has-current-solutions 
                                 (role-value ?psm has-candidate-solutions))
                 (if (exists ?sol
                             (and (member ?sol (role-value 
                                                ?psm 'has-current-solutions))
                                  (admissible-solution 
                                   ?sol 
                                   (apply-match-criterion
                                    (role-value 
                                     ?psm 'has-match-criterion)
                                    (role-value 
                                     ?psm 'has-observables)
                                    ?sol)
                                   (role-value 
                                    ?psm 
                                    'has-solution-admissibility-criterion))))
                    ?sol
                    (in-environment 
                      ((?current-sols . (role-value 
                                              ?psm 'has-current-solutions))
                       (?ranked-solutions . (achieve-generic-subtask 
                                             ?psm rank-solutions
                                             'has-observables ?obs 
                                             'has-candidate-solutions  
                                             ?current-sols
                                             'has-match-criterion 
                                             (role-value 
                                              ?psm has-match-criterion))))
                      (loop for ?candidate in ?ranked-solutions
                            do
                            (in-environment 
                             ((?refined-sols . (achieve-generic-subtask 
                                                ?psm refinement
                                                'has-basic-solutions (list-of ?candidate) 
                                                'has-observables ?obs 
                                                'has-refiners (role-value 
                                                               ?psm has-refiners))))
                             (if (not (same-set ?refined-sols (list-of ?candidate)))
                                 (in-environment 
                                  ((?result . (achieve-generic-subtask 
                                               ?psm heuristic-single-sol-classifier
                                               'has-observables ?obs 
                                               'has-candidate-solutions ?refined-sols)))
                                  (if (not (= ?result :nothing))
                                    (return ?result))))))))))))
    (has-output-mapping 
     :value '(lambda (?psm ?result)
               (list-of ?result))))
 
   :own-slots ((tackles-task-type single-solution-classification-task)
               (has-generic-subtasks '(abstraction 
                                       refinement rank-solutions))))
                                      



;;;HEURISTIC-CLASSIFICATION-PSM
(def-class heuristic-classification-psm (problem-solving-method) ?psm
  "This method tackles classification tasks by introducing three phases: abstraction, 
   match and refinement.
   An important aspect of this method is that, while the classification tasks assumes 
   that all solutions are given in the solution space, this PSM is able to generate 
   solutions through the refinement subtask.  This means that the PSM imposes weaker 
   requirements on the input set, than those imposed by the classification task.  
   This is a quite unique scenario.
   The main assumption of this PSM is that refinement does not make things worse - 
   i.e., the output of the refinement process contains solutions which are at least 
   as good as the input"
  ((has-input-role :value has-abstractors
                   :value has-refiners
                   )
   (has-control-role :value 'has-current-solutions)
   (has-output-role :value best-solutions)
   (has-current-solutions :type solution-space)
   (has-abstractors :type abstractors)
   (has-refiners :type refiners)
   (best-solutions :type solution-space)
   ;;;(has-composers :type list)
   (has-precondition 
    :value (kappa (?psm)
                  (every (role-value ?psm 'has-candidate-solutions)
                         (kappa (?sol)
                                (not (exists 
                                      (?ref ?sol2)
                                      (and (member ?ref (role-value 
                                                         ?psm 'has-refiners))
                                           (member ?sol2 
                                                   (role-value 
                                                    ?psm 'has-candidate-solutions))
                                           (member ?sol (apply-refiner-operator 
                                                         ?ref ?sol2))))))))
    :documentation "Each solution in solution-space is assumed to be a 'top solution' -
                    i.e., one which has not been refined through refinement application
                    from other elements of the solution space")
   (has-postcondition 
    :value (kappa (?psm ?sols)
                  (forall ?sol 
                          (=> (member ?sol ?sols)
                              (and (best-match (role-value ?task 'has-observables)
                                          ?sol
                                          (the-virtual-solution-space 
                                           (role-value ?psm 'has-refiners)
                                           (role-value ?psm 'has-candidate-solutions))
                                          (role-value ?task 'has-match-criterion))))))
    :documentation "The set of output solutions is optimal with respect to the 
                    solution space generated through refinement application")
   
   (has-assumption
    :value (kappa (?psm)
                  (forall (?subtask ?sol)
                          (=> 
                           (and (subtask-of ?subtask ?psm)
                                (refinement ?subtask)
                                (member ?sol (role-value ?subtask 
                                                         'has-basic-solutions))
                                (not (member ?sol (role-value 
                                                   ?subtask 
                                                   'has-refined-solutions))))
                           (not (best-match 
                                 (role-value ?psm 'has-observables)  
                                 ?sol
                                 (the-virtual-solution-space 
                                  (role-value ?psm 'has-refiners)
                                  (role-value ?psm 'has-candidate-solutions))
                                 (role-value ?psm 'has-match-criterion))))))
    :value (kappa (?psm)
                  (forall (?subtask ?sol)
                          (=> 
                           (and (subtask-of ?subtask ?psm)
                                (heuristic-match ?subtask)
                                (member ?sol (role-value ?subtask 
                                                         'has-candidate-solutions))
                                (not (member ?sol 
                                             (role-value ?subtask 
                                                         'has-solutions))))
                           (not (or 
                                 (best-match 
                                  (role-value ?psm 'has-observables)  
                                  ?sol
                                  (the-virtual-solution-space 
                                   (role-value ?psm 'has-refiners)
                                   (role-value ?psm 'has-candidate-solutions))
                                  (role-value ?psm 'has-match-criterion))
                                 (and 
                                  (best-match 
                                   (role-value ?psm 'has-observables)  
                                   ?sol2
                                   (the-virtual-solution-space 
                                    (role-value ?psm 'has-refiners)
                                    (role-value ?psm 'has-candidate-solutions))
                                   (role-value ?psm 'has-match-criterion))
                                  (generalised-refinement-of 
                                   ?sol2 ?sol (role-value ?psm 'has-refiners))))))))

    :value (kappa (?psm)
                  (forall (?sol1 ?sol2)
                          (=> 
                           (and (member ?sol1 (role-value ?psm 'best-solutions))
                                (member ?sol2 (role-value ?psm 'best-solutions)))
                           (not (composable-solutions ?sol1 ?sol2)))))
    
    :documentation "The assumption here is that neither refinement nor heuristic 
                    match lose optimal paths")

   (has-body 
    :value '(lambda (?psm)
              (in-environment                                              
               ((?obs . (achieve-generic-subtask 
                         ?psm abstraction
                         'has-observables (role-value ?psm has-observables)
                         'has-abstractors (role-value ?psm has-abstractors))))
               (do
                 (set-role-value ?psm 'has-current-solutions 
                                 (role-value ?psm has-candidate-solutions))
                 (repeat
                  (in-environment 
                   ((?best-scores-solutions . (achieve-generic-subtask 
                                               ?psm heuristic-match
                                               'has-observables ?obs 
                                               'has-candidate-solutions  
                                               (role-value 
                                                ?psm 'has-current-solutions)
                                               'has-match-criterion 
                                               (role-value 
                                                ?psm has-match-criterion)))
                    (?best-solutions . (map 'second ?best-scores-solutions))
                    (?refined-sols . (achieve-generic-subtask 
                                      ?psm refinement
                                      'has-basic-solutions ?best-solutions 
                                      'has-observables ?obs 
                                      'has-refiners (role-value 
                                                     ?psm has-refiners))))
                   
                   (if (same-set ?refined-sols ?best-solutions)
                     (return (achieve-generic-subtask 
                              ?psm filter-admissible-solutions
                              'has-score-solution-pairs  ?best-scores-solutions
                              'has-solution-admissibility-criterion
                              (role-value ?psm 
                                          'has-solution-admissibility-criterion)))
                     (set-role-value ?psm 'has-current-solutions 
                                     ?refined-sols)))))))))
  :own-slots ((tackles-task-type classification-task)
              (has-generic-subtasks '(abstraction heuristic-match refinement 
                                      filter-admissible-solutions))))


;;;;;;;;;;;;;;;;;;;;; Beginning of abstraction ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def-class abstractor (function) 
  ((domain :value observables)
   (range :value observable)
   (applicability-condition :type abstractor-applicability-condition-class)))

(def-class abstractor-applicability-condition-class (unary-relation) ?x
  "The applicability condition for an abstractor must be a relation whose domain is 
    a subset of observables"
  :iff-def (subset (the ?d (domain ?x ?d))
                   observables))

 
(def-function apply-abstract-operator (?ab ?observables-in) -> ?ob
   :constraint (and (abstractor ?ab)
                    (observable ?ob)
                    (observables ?observables-in)
                    )
   :body (if (abstractor-is-applicable? ?ab ?observables-in)
           (call (the ?body (has-body ?ab ?body))
                 ?observables-in)))

(def-relation abstractor-is-applicable? (?ab ?observables)
  :constraint (and (abstractor ?ab)
                   (observables ?observables))
  :iff-def (holds (the ?appl (applicability-condition ?ab ?appl)) ?observables))


(def-class abstraction (goal-specification-task) ?task
  "The goal of this task is to abstract from the given observables, using the given 
   abstractors.  Note that the output also includes the original (non-abstracted) 
   observables"
   ((has-input-role :value has-observables
                    :value has-abstractors)
    (has-output-role :value has-abstract-observables)
    (has-observables :type observables)
    (has-abstract-observables :type observables)
    (has-abstractors :type list)
    (has-goal-expression 
      :value (kappa (?task ?observables)
                    (and (generalized-abstract-from ?observables 
                                        (role-value ?task has-observables) 
                                        (role-value ?task has-abstractors))
                         (forall ?ab (=> (member ?ab (role-value 
                                                      ?task has-abstractors))  
                                         (not (abstractor-is-applicable? 
                                               ?ab 
                                               ?observables))))))))
   :constraint (subset (role-value ?task 'has-observables)
                       (role-value ?task 'has-abstract-observables)))


(def-relation generalized-abstract-from (?observables-out ?observables-in ?abs)
  :constraint (and (observables ?observables-out)
                   (observables ?observables-in)
                   (abstractors ?abs))

  :iff-def (forall (?ob)
                   (=> (member ?ob ?observables-out)
                       (or (member ?ob ?observables-in)
                           (observable-abstracted-from ?ob ?observables-in ?abs)))))


(def-relation observable-abstracted-from (?ob ?observables ?abs)
  :iff-def (or (directly-abstracted-from ?ob ?observables ?abs)
               (exists (?observables2)
                       (generalized-abstract-from ?observables2 ?observables ?abs)
                       (member ?ob ?observables2))))

(def-relation directly-abstracted-from (?ob ?observables ?abs)
  :constraint (and (observables ?observables)
                   (observable ?ob)
                   (abstractors ?abs))
  :iff-def (exists (?ab)
                   (and (member ?ab ?abs)
                        (abstractor-is-applicable? ?ab ?observables)
                        (member ?ob (apply-abstract-operator ?ab ?observables)))))
                        

  
(def-class abstraction-psm (primitive-method) ?psm
 "This method applies abstractors to the given data space (observables) repeatedly 
  until no abstractor can be used and returns a data space in which 
  all possible abstractions are done"

 ((has-control-role :value has-current-observables
                    :value has-current-abstractors)
  (has-current-observables :type observables)
  (has-current-abstractors :type list)
  (has-body 
   :value  '(lambda (?psm)
              (do 
                (set-role-value ?psm 
                                'has-current-observables 
                                (role-value ?psm 'has-observables))
                (set-role-value ?psm 'has-current-abstractors 
                                (role-value ?psm 'has-abstractors))
                (repeat
                 (in-environment 
                  ((?ab . (achieve-generic-subtask 
                           ?psm select-abstractor
                           'has-observables 
                           (role-value 
                            ?psm 'has-current-observables)
                           'has-abstractors 
                           (role-value 
                            ?psm 'has-current-abstractors))))
                  (if (abstractor ?ab)
                    (do  
                      (set-role-value 
                       ?psm 'has-current-abstractors 
                       (remove ?ab 
                               (role-value 
                                ?psm 
                                'has-current-abstractors)))
                      (in-environment 
                       ((?obs . (the ?obs2 (has-current-observables ?psm ?obs2)))
                        (?ob . (achieve-generic-subtask ?psm one-step-abstraction
                                                        'has-abstractor ?ab
                                                        'has-observables ?obs)))
                       (if (and (observable ?ob)
                                (not (member ?ob ?obs)))
                         (set-role-value ?psm 'has-current-observables 
                                         (cons ?ob ?obs)))))
                    (return (role-value ?psm 'has-current-observables)))))))))
 :own-slots ((tackles-task-type 'abstraction)))

(def-class select-abstractor (goal-specification-task) ?task
   ((has-input-role :value has-observables
                    :value has-abstractors)
    (has-output-role :value has-abstractor)
    (has-observables :type observables)
    (has-abstractors  :type list)
    (has-abstractor :type abstractor)
    (has-goal-expression 
     :value 
     (kappa (?task ?abstractor)
            (and (member ?abstractor (role-value ?task 'has-abstractors))
                 (abstractor-is-applicable?  
                  ?abstractor (role-value ?task 'has-observables))
                 (= ?ob (apply-abstract-operator 
                         ?abstractor (role-value ?task 'has-observables)))
                 (not (member ?ob (role-value ?task 'has-observables))))))))

(def-class select-abstractor-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm)
                       (the ?x 
                         (holds (the ?exp (has-goal-expression 
                                           (the ?task (tackles-task ?psm ?task)) 
                                           ?exp))
                                ?psm
                                ?x)))))
 :own-slots ((tackles-task-type 'select-abstractor)))




(def-class one-step-abstraction (goal-specification-task) ?task
   ((has-input-role :value has-observables
                    :value has-abstractor)
    (has-output-role :value has-abstract-observable)
    (has-observables :type observables)
    (has-abstractor  :type abstractor)
    (has-abstract-observable :type observable)
    (has-goal-expression 
      :value (kappa (?task ?observable)
                    (directly-abstracted-from ?observable 
                                              (role-value ?task 'has-observables)
                                              (list (role-value ?task 
                                                                'has-abstractor)))))))


(def-class one-step-abstraction-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm) 
                       (apply-abstract-operator 
                        (role-value ?psm 'has-abstractor) 
                        (role-value ?psm 'has-observables)))))
 :own-slots ((tackles-task-type 'one-step-abstraction)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;; end of abstraction  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;RANK-SOLUTIONS
(def-class rank-solutions (goal-specification-task) ?task 
  ((has-input-role :value has-candidate-solutions
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value has-solutions)
   (has-candidate-solutions :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (has-solutions :type solution-space)
   (has-goal-expression 
    :documentation 
    "The goal is to rank the classes according to the match criterion.  
     The output should be a list of solutions, in which no solution follows
     one which is worse"
    :value (kappa (?task ?solutions)
                  (forall (?sol1 ?sol2)
                          (=> (and (member ?sol1 ?solutions)
                                   (member ?sol2 ?solutions)
                                   (precedes ?sol1 ?sol2 ?solutions)) 
                              (not (better-match-score ?sol2 ?sol1))))))))


(def-class  rank-solutions-psm (primitive-method) ?psm
  
  ((has-input-role :value has-candidate-solutions
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value has-ranked-solutions)
   (has-control-role :value has-sol-score-pairs)
   (has-sol-score-pairs :type list
                        :default-value nil)
   (has-candidate-solutions 
                            :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (has-ranked-solutions :type list)
   (has-precondition 
    :documentation "A list of candidates is required as input"
    :value (kappa (?psm)
                  (list (role-value 
                         ?psm 'has-candidate-solutions))))
   (has-postcondition  
    :value (kappa (?psm ?solutions)
                  (forall (?sol1 ?sol2)
                          (=> (and (member ?sol1 ?solutions)
                                   (member ?sol2 ?solutions)
                                   (precedes ?sol1 ?sol2 ?solutions)) 
                              (not (better-match-score ?sol2 ?sol1))))))
   (has-body 
      :value '(lambda (?psm) 
                (do
                  (loop for ?candidate in (role-value 
                                           ?psm 'has-candidate-solutions)
                      do
                      (set-role-value 
                       ?psm has-sol-score-pairs
                                      (cons (list-of ?candidate
                                                  (achieve-generic-subtask 
                                                   ?psm basic-heuristic-match
                                                   'has-observables 
                                                   (role-value 
                                                    ?psm 
                                                   has-observables )
                                                   'has-candidate-solution ?candidate
                                                   'has-match-criterion 
                                                   (role-value 
                                                    ?psm 
                                                    has-match-criterion)))
                                            (role-value  ?psm has-sol-score-pairs))))
                  (map '(lambda (?pair)
                          (first ?pair))
                       (sort (role-value  ?psm has-sol-score-pairs)
                             '(kappa (?pair1 ?pair2)
                                    (better-match-score  (second ?pair1)(second ?pair2)
                                                         (role-value 
                                                          ?psm 
                                                          'has-match-criterion)))))))))
  :own-slots ((has-generic-subtasks '(basic-heuristic-match))
              (tackles-task-type 'rank-solutions)))


(def-class basic-heuristic-match (goal-specification-task) ?task 
  
  ((has-input-role :value has-candidate-solution
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value has-score)
   (has-candidate-solution :type solution)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (has-score :type match-score)
   (has-goal-expression 
    ;;the goal is to find the best matching classes
    :value (kappa (?task ?score)
                  (match-score ?score)))))

(def-class  basic-heuristic-match-psm (primitive-method) ?psm
  
  ((has-precondition 
    :documentation "A list of candidates is required as input"
    :value (kappa (?psm)
                  (and (solution (role-value 
                                  ?psm 'has-candidate-solution))
                       (exists ?x 
                               (member ?X (role-value 
                                           ?psm 'has-observables))))))
   
   (has-postcondition  
    :value (kappa (?psm ?score)
                  (match-score ?score)))
   (has-body 
      :value '(lambda (?psm) 
                (apply-match-criterion
                    (role-value 
                     ?psm 'has-match-criterion)
                    (role-value 
                     ?psm 'has-observables)
                    (role-value 
                     ?psm 'has-candidate-solution)))))
   :own-slots (
              (tackles-task-type 'basic-heuristic-match)))



;;;;;;;;;;;;;;;;;;;;;;;; beginning of heuristic-match  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;TASK HEURISTIC-MATCH
(def-class heuristic-match (goal-specification-task) ?task 
  "Heuristic match is defined here as finding the best candidates,
   out of a list of solutions, to explain the features of a 
   given instance.  We assume that a relation is provided, 
   has-feature, which associates the instance of an instance 
   or class to its features"
  ((has-input-role :value has-candidate-solutions
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value has-solutions)
   (has-candidate-solutions :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (has-solutions :type solution-space)
   (has-goal-expression 
    ;;the goal is to find the best matching classes
    :value (kappa (?task ?solutions)
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (best-match (role-value ?task has-observables)
                                          ?sol
                                          (role-value ?task has-candidate-solutions)
                                          (role-value ?task 
                                                      has-match-criterion))))))))

(def-class  heuristic-match-psm (primitive-method) ?psm
  "This method simple iterates over all candidates, classifying
   the observables with respect to each candidate and then 
   returning the best explaining classes with respect to the criterion"
  ((has-input-role :value has-candidate-solutions
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value has-solutions)
   (has-candidate-solutions :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (has-solutions :type solution-space)
   (has-postcondition  
    :value (kappa (?psm ?solutions)
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (best-match (role-value ?task has-observables)
                                          ?sol
                                          (role-value ?task has-candidate-solutions)
                                          (role-value ?task has-match-criterion))))))
   (has-body 
      :value '(lambda (?psm) 
           (heuristic-match-procedure (role-value ?psm has-observables)
                                          (role-value ?psm has-candidate-solutions)
                                          (role-value ?psm has-match-criterion)))))
 :own-slots ((tackles-task-type 'heuristic-match)))




(def-procedure  heuristic-match-procedure (?obs ?solutions ?criterion)
  :lisp-fun #'(lambda (obs solutions criterion)
                      (do-heuristic-match obs solutions criterion)))

(defun do-heuristic-match (obs candidates criterion)
    (when candidates
      (let* ((best-score (ocml-eval-gen 
                          `(apply-match-criterion
                            ',criterion ',obs ',(car candidates))))
             (best-score-candidate-pairs 
              (list (list best-score (car candidates)))))
           
        (dolist (c (cdr candidates))
          (let* ((c-score (ocml-eval-gen 
                           `(apply-match-criterion ',criterion ',obs ',c)))
                 (winner (ocml-eval-gen 
                          `(the-better-match-score 
                            ',best-score ',c-score ',criterion))))
            (cond ((equal winner :equal)
                   (push (list c-score c) best-score-candidate-pairs))
                  
                  ((equal winner c-score)
                   (setf best-score c-score)
                   (setf best-score-candidate-pairs (List (list c-score c)))))))
                   
          best-score-candidate-pairs)))
 
;;;;;;;;;;REFINEMENT TASK;;;;;;;;;;;;;;;;;;;;;;;;;


;;;CLASS REFINER
(def-class refiner (function) 
  ((domain :value solution)
   (range :value solution-space)
   (applicability-condition :type refiner-applicability-condition-class)))

(def-class refiner-applicability-condition-class (unary-relation) ?x
  "The applicability condition for a refiner must be a relation whose domain is 
    a subset of class solution"
  :iff-def (subset ?x solution))

(def-relation refiner-is-applicable? (?ref ?solution)
  :constraint (and (solution ?solution)
                   (refiner ?ref))
  :iff-def (holds (the ?appl (applicability-condition ?ref ?appl)) ?solution))

(def-relation some-refiner-is-applicable? (?refs ?solution)
  :constraint (and (solution ?solution)
                   (list ?refs))
  :iff-def (exists ?ref (and (member ?ref ?refs)
                             (refiner-is-applicable? ?ref ?solution))))
                             

(def-function apply-refiner-operator (?ref ?solution) -> ?sols
   :constraint (and (solution-space ?sols)
                    (refiner ?ref)
                    (solution ?solution)
                    )
   :body (if (refiner-is-applicable? ?ref ?solution)
           (call (the ?body (has-body ?ref ?body))
                 ?solution)))


;;;GENERALISED-REFINEMENT-OF
(def-relation generalised-refinement-of (?sol-out ?sol-in ?refs)
  :iff-def (or (exists ?ref (and (member ?ref ?refs)
                                 (member ?sol-out (apply-refiner-operator 
                                                   ?ref ?sol-in))))
               (exists ?sol-temp
                       (and (generalised-refinement-of ?sol-temp ?sol-in ?refs)
                            (generalised-refinement-of ?sol-out ?sol-temp ?refs)))))
                            


;;;REFINEMENT-THROUGH-SUBCLASS-OF-LINKS
(def-instance refinement-through-subclass-of-links refiner
  "If the solution space is specified by means of classes arranged in a subclass-of
   hierarchy, then this is a good refiner to use"
  ((has-body '(lambda (?sol)
                (setofall ?sub (direct-subclass-of ?sub ?sol))))
   (applicability-condition (kappa (?sol)
                                   (and (class ?sol)
                                        (exists ?sub (direct-subclass-of ?sub ?sol)))))))
;;;TASK REFINEMENT
(def-class refinement (goal-specification-task) ?task
  "The goal of this task is to take the current set of best solutions at a given 
   level of refinement, say n, and to try refine each of them in turn, using the 
   given set of refiners. All refiners are tried for each solution at level n, but 
   the refinement hiearchy is navigated down 1 level only.  That is, the output will 
   include at most solutions at level n+1.
   If a solution at level n cannot be refined, this will be also part of the output.  That is, the output
   includes all the new solutions of level n+1, plus all the 'old solutions' for 
   which no refiner is applicable"
 ((has-input-role :value has-basic-solutions
                  :value has-observables
                  :value has-refiners)
  (has-output-role :value has-refined-solutions)
  (has-basic-solutions :type solution-space)
  (has-observables :type observables)
  (has-refined-solutions :type solution-space)
  (has-refiners :type list)
  (has-goal-expression
     :value
     (kappa (?task ?solutions)
            (forall ?sol
                    (=> (member ?sol ?solutions)
                        (or (and (member ?sol (role-value 
                                               ?task 'has-basic-solutions))
                                 (not (some-refiner-is-applicable? 
                                       (role-value ?task has-refiners)?sol)))
                            (and (not (member ?sol 
                                              (role-value ?task 
                                                          'has-basic-solutions)))
                                 (exists (?sol2 ?ref)
                                         (member ?sol2 
                                                 (role-value ?task 
                                                             'has-basic-solutions))
                                         (member ?ref (role-value 
                                                       ?task has-refiners))
                                         (not (member ?sol2 ?solutions))
                                         (member ?sol (apply-refiner-operator 
                                                       ?ref ?sol2)))))))))))
                               

(def-relation most-specific-solution (?solution ?refiners)
 :iff-def (not (exists (?refiner)
                       (and  (member ?refiner ?refiners) 
                             (refiner-is-applicable? ?refiner ?solution)))))

 

(def-class refinement-psm (decomposition-method) ?psm
  "This method applies refiners to the given set of solutions repeatedly 
  until no refinement can be executed and returns the set of most specific solutions"
  
  ((has-control-role :value has-current-refined-solutions)
   (has-current-refined-solutions :type solution-space)
   (has-assumption 
    :value 
    (kappa (?psm)
           (forall (?sol-out ?sol-in ?ref)
                   (=> (and (member ?sol-out (role-value ?psm 
                                                         'has-refined-solutions))
                            (member ?sol-in (role-value ?psm 'has-basic-solutions))
                            (member ?ref (role-value ?psm 'has-refiners))
                            (member ?sol-out (apply-refiner-operator 
                                              ?ref 
                                              ?sol-in)))
                       (better-match-than ?sol-out ?sol-in 
                                          (role-value ?psm 'has-observables)
                                          (role-value ?psm 'has-match-criterion)))))
    :documentation "Refinement does not make things worse")
                                     
   (has-body 
    :value 
    '(lambda (?psm)
       (do 
         (set-role-value ?psm 'has-current-refined-solutions nil)
         (loop for ?sol in (role-value ?psm 'has-basic-solutions)
               do
               (in-environment 
                ((?refs . (achieve-generic-subtask 
                           ?psm collect-refiners 
                           has-solution ?sol
                           has-refiners (role-value ?psm has-refiners)))
                 (?new-sols . (achieve-generic-subtask ?psm apply-refiners 
                                                       has-solution ?sol
                                                       has-refiners ?refs)))
                (if (= ?new-sols nil)
                  (set-role-value ?psm 'has-current-refined-solutions 
                                  (cons ?sol 
                                        (role-value 
                                         ?psm
                                         'has-current-refined-solutions)))
                  (set-role-value ?psm 'has-current-refined-solutions 
                                  (append 
                                   ?new-sols 
                                   (role-value ?psm 
                                               'has-current-refined-solutions))))))
         (role-value ?psm 'has-current-refined-solutions)))))
 :own-slots ((tackles-task-type 'refinement)))

(def-class cautious-refinement-psm (decomposition-method) ?psm
  "This method applies refiners to the given set of solutions repeatedly 
  until no refinement can be executed and returns the set of most specific solutions.
  This method is cautious, in the sense that it does not assume that a refiner 
  necessarily produces a better solution.  Therefore, it will test the refined 
  solutions to check that they are indeed an improvement over their 'parent solution'."
  
  ((has-control-role :value has-current-refined-solutions)
   (has-current-refined-solutions :type solution-space)
   (has-postcondition 
    :value (kappa (?psm ?solutions)
                  (forall (?sol-out ?sol-in ?ref)
                          (=> (and (member ?sol-out ?solutions)
                                   (member ?sol-in (role-value ?psm 
                                                               'has-basic-solutions))
                                   (member ?ref (role-value ?psm 'has-refiners))
                                   (member ?sol-out (apply-refiner-operator 
                                                     ?ref 
                                                     ?sol-in)))
                              (better-match-than ?sol-out ?sol-in 
                                                 (role-value ?psm 
                                                             'has-observables)
                                                 (role-value ?psm 
                                                             'has-match-criterion)))))
    :documentation "Our PSM ensures that refinement does not make things worse")
                                     
   (has-body 
    :value 
    '(lambda (?psm)
       (do 
         (set-role-value ?psm 'has-current-refined-solutions nil)
         (loop for ?sol in (role-value ?psm 'has-basic-solutions)
               do
               (in-environment 
                ((?refs . (achieve-generic-subtask 
                           ?psm collect-refiners 
                           has-solution ?sol
                           has-refiners 
                           (role-value ?psm 
                                       has-refiners)))
                 (?new-sols . (achieve-generic-subtask ?psm apply-refiners 
                                                       has-solution ?sol
                                                       has-refiners ?refs)))
                (if (= ?new-sols nil)
                  (set-role-value ?psm 'has-current-refined-solutions 
                                  (cons ?sol 
                                        (role-value 
                                         ?psm 
                                         'has-current-refined-solutions)))
                  (set-role-value 
                   ?psm 'has-current-refined-solutions 
                   (append (map 'second 
                                (achieve-generic-subtask 
                                 ?psm heuristic-match
                                 'has-observables (role-value ?psm 'has-observables)
                                 'has-candidate-solutions  (cons ?sol ?new-sols)
                                 'has-match-criterion (role-value 
                                                       ?psm has-match-criterion)))
                           (role-value ?psm 'has-current-refined-solutions))))))
         (role-value ?psm 'has-current-refined-solutions)))))
 :own-slots ((tackles-task-type 'refinement)))

  

(def-class select-solution (goal-specification-task) ?task
   ((has-input-role :value has-solutions)
    (has-output-role :value has-selected-solution)
    (has-solutions :type solution-space)
    (has-selected-solution  :type solution)
    (has-goal-expression 
      :value (kappa (?task ?solution)
                    (member ?solution (role-value ?task has-solutions))))))


(def-class random-select-solution-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm) 
                       (the ?x (member ?x (role-value ?psm has-solutions))))))
  :own-slots ((tackles-task-type 'select-solution)))



(def-class  collect-refiners (goal-specification-task) ?task
   ((has-input-role :value has-solution
                    :value has-refiners)
    (has-output-role :value has-applicable-refiners)
    (has-solution :type solution)
    (has-refiners :type list)
    (has-applicable-refiners :type list)
    (has-goal-expression 
      :value (kappa (?task ?refiners)
                    (and (subset ?refiners (role-value ?task has-refiners))
                         (not (exists (?ref)
                                      (and (member ?ref ?refiners)
                                           (not (refiner-is-applicable? 
                                                 ?ref (role-value
                                                       ?task has-solution)))))))))))

(def-class standard-collect-refiners-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm)
                       (setofall ?x (and (member ?x (role-value ?psm has-refiners))
                                      (refiner-is-applicable? 
                                       ?x (role-value ?psm has-solution)))))))

  :own-slots ((tackles-task-type 'collect-refiners)))


;;;TASK APPLY-REFINERS
(def-class  apply-refiners (goal-specification-task) ?task
  "The goal of this task is to generate all possible refinement of a solution, given
   a set of refiners.  Only one-step refinement is carried out here.  That is, if the 
   input solution is defined at level n, the output can only be at level n+1."
   ((has-input-role :value has-solution
                    :value has-refiners)
    (has-output-role :value has-refined-solutions)
    (has-solution :type solution)
    (has-refiners :type list)
    (has-refined-solutions :type solution-space)
    (has-goal-expression 
      :value (kappa (?task ?solutions) 
                    (forall ?sol
                            (=> (member ?sol ?solutions)
                                (exists ?ref 
                                        (and (member 
                                              ?ref (role-value ?task 'has-refiners)
                                              (member ?sol 
                                                      (apply-refiner-operator 
                                                       ?ref 
                                                       (role-value 
                                                        ?task 
                                                        'has-solution))))))))))))

;;;METHOD APPLY-REFINERS-PSM
(def-class apply-refiners-psm (problem-solving-method) ?psm
  ((has-control-role :value has-current-solutions)
   (has-current-solutions :type solution-space)
   (has-precondition :value (kappa (?psm)
                                   (every (role-value ?psm 'has-refiners)
                                          (kappa (?x)
                                                 (refiner-is-applicable? 
                                                  ?x 
                                                  (role-value 
                                                   ?psm has-solution))))))
                     
                                          
   (has-body :value 
             '(lambda (?psm)
                (do
                  (set-role-value ?psm 'has-current-solutions nil)
                  (loop for ?ref in (role-value ?psm has-refiners)
                        do
                        (in-environment
                         ((?sols . (apply-refiner-operator
                                    ?ref 
                                    (role-value ?psm 'has-solution))))
                         (set-role-value ?psm 'has-current-solutions 
                                         (union (role-value ?psm 
                                                            'has-current-solutions)
                                                ?sols))))
                  (role-value ?psm 
                              'has-current-solutions)))))

 :own-slots ((tackles-task-type 'apply-refiners)
             ))


;;;;;;;;;;;;;;;;;;;;;;;;;;; Solution Filtering;;;;;;;;;;;;;;;;;;;;;;;
(def-class filter-admissible-solutions (goal-specification-task) ?task
  "The goal of this task is to filter out solutions which are not admissible"
   ((has-input-role :value has-solution-admissibility-criterion
                    :value has-score-solution-pairs)
    (has-output-role :value has-admissible-solutions)
    (has-solution-admissibility-criterion :type solution-admissibility-criterion)
    (has-score-solution-pairs :type list)
    (has-admissible-solutions :type solution-space)
    (has-precondition 
     :value (kappa (?task )
                   (and (solution-admissibility-criterion
                         (role-value ?task has-solution-admissibility-criterion))
                        (exists ?pair
                                (member ?pair (role-value 
                                               ?task has-score-solution-pairs))))))
    (has-goal-expression
     :value (kappa (?task ?sols)
                   (forall ?sol
                           (=> (member ?sol ?sols)
                               (exists ?score
                                       (and (member (?score ?sol) 
                                                    (role-value 
                                                     ?task 
                                                     has-score-solution-pairs))
                                            (admissible-solution 
                                             ?sol ?score 
                                             (role-value 
                                              ?task 
                                              has-solution-admissibility-criterion))))))))))
                   
(def-class filter-admissible-solutions-psm (primitive-method) ?psm
  ((has-control-role :value current-admissible-solutions)
   (current-admissible-solutions :type list)
   (has-body 
    :value 
    '(lambda (?psm)
       (do
         (set-role-value ?psm 'current-admissible-solutions
                         nil)
         (loop for ?pair in (role-value ?psm has-score-solution-pairs)
               do
               (if (admissible-solution 
                    (second ?pair)(first ?pair)
                    (role-value 
                     ?psm 
                     'has-solution-admissibility-criterion))
                 (set-role-value ?psm 'current-admissible-solutions
                                 (cons (second ?pair)
                                       (role-value 
                                        ?psm 'current-admissible-solutions)))))
         (role-value ?psm 'current-admissible-solutions)
         ))))
                
  :own-slots ((tackles-task-type ' filter-admissible-solutions)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


(def-class solution-evaluation (goal-specification-task) ?task
  "The goal of this task is to evaluate solutions"
   ((has-input-role :value has-composers
                    :value has-score-solution-pairs
                    :value has-solution-evaluating-criterions)
    (has-output-role :value has-solution-evaluating-criterions)
    (has-composers :type list)
    (has-score-solution-pairs :type list)
    (has-solution-evaluating-criterions :type solution-evaluating-criterions)
    (has-evaluated-solutions :type list)))
   
    ;(has-goal-expression 
    ;  :value (kappa (?task ?solutions)
    
(def-class solution-evaluation-psm (problem-solving-method) ?psm
  ((has-body 
    :value 
    '(lambda (?psm)
       (in-environment
        ((?current-criterions . (role-value 
                                 ?psm 
                                 'has-solution-evaluating-criterions))
         (?new-best-score-solution-pairs . (achieve-generic-subtask 
                                            ?psm composite-solutions
                                            'has-score-solution-pairs 
                                            (role-value ?psm 'has-score-solution-pairs) 
                                            'has-composers  
                                            (role-value ?psm 'has-composers)
                                            'has-composite-solution-score-mechanism 
                                            (the-slot-value 
                                             ?current-criterions  
                                             has-composite-solution-score-mechanism)))
         (?qualified-solutions . (achieve-generic-subtask 
                                  ?psm qualification
                                  'has-score-solution-pairs 
                                  ?new-best-score-solution-pairs
                                  'has-qualification-criterion 
                                  (the-slot-value 
                                   ?current-criterions
                                   'has-qualification-criterion))))
        (achieve-generic-subtask ?psm ranking-solutions
                                 'has-score-solution-pairs ?qualified-solutions 
                                 'has-ranking-criterion 
                                 (the-slot-value 
                                  ?current-criterions  
                                  has-ranking-criterion))))))
                                                                       
 :own-slots ((tackles-task-type 'solution-evaluation)
             (has-generic-subtasks '(composite-solutions 
                                     qualification ranking-solutions))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;  Task composite-solutions   ;;;;;;;;;;;;;;;;;;;;;;;;;
(def-class composer (set) ?comp
  :iff-def (every ?comp solution))

(def-class composite-solutions (goal-specification-task) ?task
  "The goal of this task is to find all composite solutions"
   ((has-input-role :value has-score-solution-pairs
                    :value has-composers
                    :value has-composite-solution-score-mechanism)
    (has-output-role :value has-composed-score-solution-pairs)
    (has-score-solution-pairs :type list)
    (has-composers :type list)
    (has-composite-solution-score-mechanism :type composite-solution-score-mechanism)
    (has-composed-score-solution-pairs :type list)))


(def-class composite-solutions-psm (problem-solving-method) ?psm
 ((has-control-role :value has-current-composite-score-solution-pairs
                    :value has-current-composers)
  (has-current-score-solution-pairs :type list)
  (has-current-composers :type list)
  (has-body :value 
       '(lambda (?psm) 
         (do 
            (set-role-value ?psm 'has-current-composite-score-solution-pairs nil)
            (set-role-value ?psm 'has-current-composers 
                            (role-value ?psm 'has-composers))
            (repeat
               (in-environment 
                ((?composer . (achieve-generic-subtask 
                               ?psm select-composer
                               'has-solutions 
                               (map 'second (role-value 
                                             ?psm 'has-score-solution-pairs))
                               'has-composers (role-value ?psm 'has-composers))))
                (if (composer ?composer)
                    (do  
                        (set-role-value ?psm 'has-current-composers 
                                        (remove ?composer 
                                                (role-value ?psm 
                                                            'has-current-composers)))
                        (in-environment 
                         ((?composite-score-sol-pair . (achieve-generic-subtask 
                                                        ?psm apply-composer
                                                        'has-composer ?composer
                                                        'has-score-solution-pairs 
                                                        (role-value 
                                                         ?psm 
                                                         'has-score-solution-pairs)
                                                        'has-composite-solution-score-mechanism
                                                        (role-value ?psm 'has-composite-solution-score-mechanism))))
                         (set-role-value ?psm 'has-current-composite-score-solution-pairs 
                                              (cons ?composite-score-sol-pair 
                                                     (role-value 
                                                      ?psm
                                                      'has-current-score-solution-pairs)))))

                  (return (append (role-value 
                                   ?psm 
                                   'has-current-composite-score-solution-pairs) 
                                  (role-value 
                                   ?psm 'has-score-solution-pairs))))))))))
 :own-slots ((tackles-task-type 'composite-solutions)))
                                 


(def-class select-composer (goal-specification-task) ?task
   ((has-input-role :value has-solutions
                    :value has-composers)
    (has-output-role :value has-composer)
    (has-solutions :type list)
    (has-composers  :type list)
    (has-composer :type composer)))
    ;(has-goal-expression 
    ;  :value (kappa (?task ?abstractor)
    ;                (and (member ?abstractor (role-value ?task 'has-abstractors))
    ;                     (abstractor-is-applicable?  ?abstractor (role-value ?task 'has-observables))
    ;                     (= ?ob (apply-abstract-operator ?abstractor (role-value ?task 'has-observables)))
    ;                     (not (member ?ob (role-value ?task 'has-observables))))))))

(def-class select-composer-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm)
                       (the ?x (and (member ?x (role-value ?psm has-composers))
                                    (not (NULL (intersection ?x (role-value ?psm has-solutions)))))))))
                               
 :own-slots ((tackles-task-type 'select-composer)))



(def-class apply-composer (goal-specification-task) ?task
 ((has-input-role :value has-composer
                  :value has-score-solution-pairs
                  :value has-composite-solution-score-mechanism)
  (has-output-role :value composite-score-solution-pair)
  (has-composer :type composer)
  (has-score-solution-pairs :type list)
  (has-composite-solution-score-mechanism :type composite-solution-score-mechanism)
  (composite-score-solution-pair :type pair)))

(def-class apply-composer-psm (problem-solving-method) ?psm
  ((has-body 
     :value '(lambda (?psm)
      (in-environment 
         ((composible-score-solution-pairs . (findall ?x (and (member ?x (role-value ?psm has-score-solution-pairs))
                                                              (member (second ?x) (role-value ?psm has-composer)))))        
         (?composite-score . (call (role-value ?psm has-composite-solution-score-mechanism)
                                   (map 'first composible-score-solution-pairs)))
         (?composite-solution . (map 'second composible-score-solution-pairs)))
         (list ?composite-score ?composite-solution)))))

 :own-slots ((tackles-task-type 'apply-composer)))


;;;;;;;;;;;;;;;;;;;;;;; Qualification ;;;;;;;;;;;;;;;;;;;;;;;;;

(def-class qualification (goal-specification-task) ?task
  "The goal of this task is to test if the solutions are qulified."
   ((has-input-role :value has-score-solution-pairs 
                    :value has-qualification-criterion)
    (has-output-role :value has-qualified-solutions)
    (has-score-solution-pairs :type list)
    (has-qualification-criterion :type qualification-criterion)                       
    (has-qualified-solutions :type list)))
    ;(has-goal-expression 
    ;  :value (kappa (?task ?solutions)
    ;                (and (generalized-abstract-from ?observables 
    ;                                    (role-value ?task has-observables) 
    ;                                    (role-value ?task has-abstractors))
    ;                     (forall ?ab (=> (member ?ab (role-value ?task has-abstractors))  
    ;                                     (not (abstractor-is-applicable? ?ab ?observables))))))))
    ; :constraint (subset (role-value ?task 'has-observables)
    ;                   (role-value ?task 'has-abstract-observables)))


(def-class qualification-psm (problem-solving-method) ?psm
((has-body :value 
             '(lambda (?psm)
                (in-environment
                         ((?best-score . (first (map 'first (role-value ?psm has-score-solution-pairs))))
                          (?qualification-criterion . (role-value ?psm has-qualification-criterion)))
                          (if (holds ?qualification-criterion ?best-score)
                              (role-value ?psm has-score-solution-pairs)
                              "no qualified solutions")))))

 :own-slots ((tackles-task-type 'qualification)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Ranking ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(def-class ranking-solutions (goal-specification-task) ?task
  "The goal of this task is to test if the solutions are qualified."
   ((has-input-role :value has-score-solution-pairs 
                    :value has-ranking-criterion)
    (has-output-role :value has-ranked-solutions)
    (has-score-solution-pairs :type list)
    (has-ranking-criterion :type ranking-criterion)                       
    (has-ranked-solutions :type list)))
    ;(has-goal-expression 
    ;  :value (kappa (?task ?solutions)
    ;                (and (generalized-abstract-from ?observables 
    ;                                    (role-value ?task has-observables) 
    ;                                    (role-value ?task has-abstractors))
    ;                     (forall ?ab (=> (member ?ab (role-value ?task has-abstractors))  
    ;                                     (not (abstractor-is-applicable? ?ab ?observables))))))))
    ; :constraint (subset (role-value ?task 'has-observables)
    ;                   (role-value ?task 'has-abstract-observables)))


(def-class ranking-solutions-psm (problem-solving-method) ?psm
 ((has-control-role :value current-ranked-solutions)
  (current-ranked-solutions :type list)
  (has-body :value 
             '(lambda (?psm)
               (if (string (role-value ?psm 'has-score-solution-pairs))
                   (role-value ?psm 'has-score-solution-pairs)
                 (do
                    (set-role-value ?psm current-ranked-solutions nil)
                    (loop for ?score-sol in (role-value ?psm 'has-score-solution-pairs)
                       (if (holds (role-value ?psm has-ranking-criterion (first ?score-sol)))
                          (set-role-value ?psm current-ranked-solutions (cons (second ?score-sol) current-ranked-solutions))))
                    (role-value ?psm current-ranked-solutions))))))
                     

 :own-slots ((tackles-task-type 'ranking-solutions)))
    

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun heuristic-classify (&key solution-space observables abstractors refiners 
                                domain-name
                                (task-type 'OPTIMAL-CLASSIFICATION-TASK)
                                (match-criterion 'default-match-criterion)
                                (method-type 'heuristic-classification-psm)
                                (solution-admissibility-criterion 
                                 'default-solution-admissibility-criterion))
  
  
  
  (let* ((task (define-domain-instance 
                 (gentemp "CLASSIFICATION-TASK")
                 task-type
                 ""
                 `((has-candidate-solutions ,solution-space)
                   (has-observables ,observables)
                   (has-match-criterion ,match-criterion)
                   (has-solution-admissibility-criterion 
                    ,solution-admissibility-criterion ))))
         
         (method (define-domain-instance 
                   (gentemp "METHOD")
                   method-type
                   ""
                   `((has-abstractors ,abstractors)
                     (has-refiners ,refiners))))
         (application (define-domain-instance 
                        (gentemp "CLASSIFICATION-APPLICATION")
                        'application
                        ""
                        `((tackles-domain ,domain-name)
                          (uses-method ,(name method))
                          (tackles-task ,(name task))))))
    (ocml-eval-gen `(solve-application ,(name application)))))


