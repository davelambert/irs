;;; -*- Mode: LISP; Syntax: Common-lisp; Base: 10; Package: OCML; -*- 

;;;; HEURISTIC-CLASSIFICATION :METHOD ;;;;

(in-package "OCML")

(in-ontology heuristic-classification)


;;;THE-VIRTUAL-SOLUTION-SPACE
(def-function the-virtual-solution-space (?init-space ?refs) -> ?solution-space
  "The space generated by refinement application from an initial solution space"
  :constraint (and (every ?refs refiner)
                   (solution-space ?init-space))
  :def (= ?solution-space
          (setofall ?sol2 (or (member ?sol2 ?init-space)
                              (exists (?ref ?sol3)
                                      (and (member ?ref ?refs)
                                           (member ?sol2 (apply-refiner-operator 
                                                          ?ref ?sol3))
                                           (member ?sol3 ?solution-space)))))))



;;;HEURISTIC-CLASSIFICATION-PSM
(def-class heuristic-classification-psm (decomposition-method) ?psm
  "This method tackles classification tasks by introducing three phases: abstraction, 
   match and refinement.
   An important aspect of this method is that, while the classification tasks assumes 
   that all solutions are given in the solution space, this PSM is able to 
   generate solutions through the refinement subtask.  This means
   that the PSM imposes weaker requirements on the input set, than those imposed 
   by the classification task.  This is a quite unique scenario.
   The main assumption of this PSM is that refinement does not make things worse - 
   i.e., the output of the refinement process contains solutions which are at 
   least as good as the input"
  ((has-input-role :value has-abstractors
                   :value has-refiners
                   )
   (has-control-role :value 'has-current-solutions)
   (has-output-role :value best-solutions)
   (has-current-solutions :type solution-space)
   (has-abstractors :type abstractors)
   (has-refiners :type refiners)
   (best-solutions :type solution-space)
   
   (has-precondition 
    :value (kappa (?psm)
                  (every (role-value ?psm 'has-solution-space)
                         (kappa (?sol)
                                (not 
                                 (exists 
                                  (?ref ?sol2)
                                  (and (member ?ref (role-value 
                                                     ?psm 'has-refiners))
                                       (member ?sol2 (role-value 
                                                      ?psm 'has-solution-space))
                                       (member ?sol (apply-refiner-operator 
                                                     ?ref ?sol2))))))))
    :documentation "Each solution in solution-space is assumed to be a 'top solution'- 
                    i.e., one which has not been refined through refinement application
                    from other elements of the solution space")
   (has-postcondition 
    :value (kappa (?psm ?sols)
                  (forall ?sol 
                          (=> (member ?sol ?sols)
                              (and (best-match (role-value ?task 'has-observables)
                                               ?sol
                                               (the-virtual-solution-space 
                                                (role-value 
                                                 ?psm 'has-refiners)
                                                (role-value 
                                                 ?psm 'has-solution-space))
                                               (role-value 
                                                ?task 'has-match-criterion))))))
    :documentation "The set of output solutions is optimal with respect to the  
                    solution space generated through refinement application")
   
   (has-assumption
    :value (kappa (?psm)
                  (forall (?subtask ?sol)
                          (=> 
                           (and (subtask-of ?subtask ?psm)
                                (refinement ?subtask)
                                (member ?sol (role-value ?subtask 
                                                         'has-basic-solutions))
                                (not (member ?sol 
                                             (role-value ?subtask 
                                                         'has-refined-solutions))))
                           (not (best-match 
                                 (role-value ?psm 'has-observables)  
                                 ?sol
                                 (the-virtual-solution-space 
                                  (role-value 
                                   ?psm 'has-refiners)
                                  (role-value 
                                   ?psm 'has-solution-space))
                                 (role-value ?psm 'has-match-criterion))))))
    :value (kappa (?psm)
                  (forall (?subtask ?sol)
                          (=> 
                           (and (subtask-of ?subtask ?psm)
                                (heuristic-match ?subtask)
                                (member ?sol (role-value 
                                              ?subtask 'has-solution-space))
                                (not (member ?sol (role-value 
                                                   ?subtask 
                                                   'best-matching-solutions))))
                           (not (or 
                                 (best-match 
                                  (role-value ?psm 'has-observables)  
                                  ?sol
                                  (the-virtual-solution-space 
                                   (role-value ?psm 'has-refiners)
                                   (role-value ?psm 'has-solution-space))
                                  (role-value ?psm 'has-match-criterion))
                                 (and 
                                  (best-match 
                                   (role-value ?psm 'has-observables)  
                                   ?sol2
                                   (the-virtual-solution-space 
                                    (role-value ?psm 'has-refiners)
                                    (role-value ?psm 'has-solution-space))
                                   (role-value ?psm 'has-match-criterion))
                                  (generalised-refinement-of 
                                   ?sol2 ?sol 
                                   (role-value ?psm 'has-refiners))))))))
    
    
    
    
    :documentation "The assumption here is that neither refinement nor heuristic 
                    match lose optimal paths")
   
   (has-body 
    :value '(lambda (?psm)
              (in-environment
               ((?obs . (achieve-generic-subtask 
                         ?psm abstraction
                         'has-observables (role-value ?psm has-observables)
                         'has-abstractors (role-value ?psm has-abstractors))))
               (do
                 (set-role-value ?psm 'has-current-solutions 
                                 (role-value ?psm has-solution-space))
                 (repeat
                  (in-environment 
                   ((?best-solutions . (achieve-generic-subtask 
                                        ?psm heuristic-match
                                        'has-observables ?obs 
                                        'has-solution-space  
                                        (role-value ?psm 'has-current-solutions)
                                        'has-match-criterion 
                                        (role-value ?psm has-match-criterion)))
                    (?refined-sols . (achieve-generic-subtask 
                                      ?psm refinement
                                      'has-basic-solutions ?best-solutions 
                                      'has-observables ?obs 
                                      'has-refiners (role-value ?psm has-refiners))))
                   
                   (if (same-set ?refined-sols ?best-solutions)
                     (return ?best-solutions)
                     (set-role-value ?psm 
                                     'has-current-solutions 
                                     ?refined-sols)))))))))
  
  :own-slots ((tackles-task-type classification-task)
              (has-generic-subtasks '(abstraction heuristic-match refinement))))

;;;;;;;;;;;;;;;;;;;;; Beginning of abstraction ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;CLASS ABSTRACTOR
(def-class abstractor (function) 
  ((domain :value observables)
   (range :value observable)
   (applicability-condition :type abstractor-applicability-condition-class)))

(def-class abstractor-applicability-condition-class (unary-relation) ?x
  "The applicability condition for an abstractor must be a relation whose domain is 
    a subset of observables"
  :iff-def (subset (the ?d (domain ?x ?d))
                   observables))

;;;FUNCTION APPLY-ABSTRACT-OPERATOR
(def-function apply-abstract-operator (?ab ?observables-in) -> ?ob
  :constraint (and (abstractor ?ab)
                   (observable ?ob)
                   (observables ?observables-in)
                   )
  :body (if (abstractor-is-applicable? ?ab ?observables-in)
          (call (the ?body (has-body ?ab ?body))
                ?observables-in)))

(def-relation abstractor-is-applicable? (?ab ?observables)
  :constraint (and (abstractor ?ab)
                   (observables ?observables))
  :iff-def (holds (the ?appl (applicability-condition ?ab ?appl)) ?observables))


;;;TASK ABSTRACTION
(def-class abstraction (goal-specification-task) ?task
  "The goal of this task is to abstract from the given observables, using the given 
   abstractors.  Note that the output also includes the original (non-abstracted) 
   observables"
  ((has-input-role :value has-observables
                   :value has-abstractors)
   (has-output-role :value has-abstract-observables)
   (has-observables :type observables)
   (has-abstract-observables :type observables)
   (has-abstractors :type list)
   (has-goal-expression 
    :value (kappa (?task ?observables)
                  (and (generalized-abstract-from ?observables 
                                                  (role-value ?task has-observables) 
                                                  (role-value ?task has-abstractors))
                       (forall ?ab (=> (member ?ab 
                                               (role-value ?task has-abstractors))  
                                       (not (abstractor-is-applicable? 
                                             ?ab ?observables))))))))
  :constraint (subset (role-value ?task 'has-observables)
                      (role-value ?task 'has-abstract-observables)))

;;;RELATION GENERALIZED-ABSTRACT-FROM
(def-relation generalized-abstract-from (?observables-out ?observables-in ?abs)
  :constraint (and (observables ?observables-out)
                   (observables ?observables-in)
                   (abstractors ?abs))
  
  :iff-def (forall (?ob)
                   (=> (member ?ob ?observables-out)
                       (or (member ?ob ?observables-in)
                           (observable-abstracted-from ?ob ?observables-in ?abs)))))

;;;RELATION OBSERVABLE-ABSTRACTED-FROM
(def-relation observable-abstracted-from (?ob ?observables ?abs)
  :iff-def (or (directly-abstracted-from ?ob ?observables ?abs)
               (exists (?observables2)
                       (generalized-abstract-from ?observables2 ?observables ?abs)
                       (member ?ob ?observables2))))

;;;RELATION DIRECTLY-ABSTRACTED-FROM
(def-relation directly-abstracted-from (?ob ?observables ?abs)
  :constraint (and (observables ?observables)
                   (observable ?ob)
                   (abstractors ?abs))
  :iff-def (exists (?ab)
                   (and (member ?ab ?abs)
                        (abstractor-is-applicable? ?ab ?observables)
                        (member ?ob (apply-abstract-operator ?ab ?observables)))))


;;;METHOD ABSTRACTION-PSM
(def-class abstraction-psm (decomposition-method) ?psm
  "This method applies abstractors to the given data space (observables) repeatedly 
  until no abstractor can be used and returns a data space in which 
  all possible abstractions are done"
  
  ((has-control-role :value has-current-observables
                     :value has-current-abstractors)
   (has-current-observables :type observables)
   (has-current-abstractors :type list)
   (has-body 
    :value  '(lambda (?psm)
               (do 
                 (set-role-value ?psm 'has-current-observables 
                                 (role-value ?psm 'has-observables))
                 (set-role-value ?psm 'has-current-abstractors 
                                 (role-value ?psm 'has-abstractors))
                 (repeat
                  (in-environment 
                   ((?ab . (achieve-generic-subtask 
                            ?psm select-abstractor
                            'has-observables 
                            (role-value ?psm 'has-current-observables)
                            'has-abstractors 
                            (role-value ?psm 'has-current-abstractors))))
                   (if (abstractor ?ab)
                     (do  
                       (set-role-value 
                        ?psm 'has-current-abstractors 
                        (remove ?ab 
                                (role-value ?psm 'has-current-abstractors)))
                       (in-environment 
                        ((?obs . (the ?obs2 (has-current-observables ?psm ?obs2)))
                         (?ob . (achieve-generic-subtask ?psm one-step-abstraction
                                                         'has-abstractor ?ab
                                                         'has-observables ?obs)))
                        (if (and (observable ?ob)
                                 (not (member ?ob ?obs)))
                          (set-role-value ?psm 'has-current-observables 
                                          (cons ?ob ?obs)))))
                     (return (role-value ?psm 'has-current-observables)))))))))
  :own-slots ((has-generic-subtasks '(select-abstractor one-step-abstraction))
              (tackles-task-type 'abstraction)))

(def-class select-abstractor (goal-specification-task) ?task
  ((has-input-role :value has-observables
                   :value has-abstractors)
   (has-output-role :value has-abstractor)
   (has-observables :type observables)
   (has-abstractors  :type list)
   (has-abstractor :type abstractor)
   (has-goal-expression 
    :value (kappa (?task ?abstractor)
                  (and (member ?abstractor (role-value ?task 'has-abstractors))
                       (abstractor-is-applicable?  
                        ?abstractor (role-value ?task 'has-observables))
                       (= ?ob (apply-abstract-operator 
                               ?abstractor (role-value ?task 'has-observables)))
                       (not (member ?ob (role-value ?task 'has-observables))))))))

(def-class select-abstractor-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm)
                       (the ?x 
                         (holds (the ?exp (has-goal-expression 
                                           (the ?task (tackles-task ?psm ?task)) 
                                           ?exp))
                                ?psm
                                ?x)))))
  :own-slots ((tackles-task-type 'select-abstractor)))




(def-class one-step-abstraction (goal-specification-task) ?task
  ((has-input-role :value has-observables
                   :value has-abstractor)
   (has-output-role :value has-abstract-observable)
   (has-observables :type observables)
   (has-abstractor  :type abstractor)
   (has-abstract-observable :type observable)
   (has-goal-expression 
    :value (kappa (?task ?observable)
                  (directly-abstracted-from ?observable 
                                            (role-value ?task 'has-observables)
                                            (list (role-value 
                                                   ?task 'has-abstractor)))))))

(def-class one-step-abstraction-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm) 
                       (apply-abstract-operator 
                        (role-value ?psm 'has-abstractor) 
                        (role-value ?psm 'has-observables)))))
  :own-slots ((tackles-task-type 'one-step-abstraction)))


;;;;;;;;;;;;;;;;;;;;;;;;;;;; end of abstraction  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;



;;;;;;;;;;;;;;;;;;;;;;;; begining of heuristic-match  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;TASK HEURISTIC-MATCH
(def-class heuristic-match (goal-specification-task) ?task 
  "Simple match is defined here as finding the best candidates,
   out of a list of solutions, to explain the features of a 
   given instance.  We assume that a relation is provided, 
   has-feature, which associates the instance of an instance 
   or class to its features"
  ((has-input-role :value has-solution-space
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value best-matching-solutions)
   (has-solution-space :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (best-matching-solutions :type solution-space)
   (has-goal-expression 
    ;;the goal is to find the best matching classes
    :value (kappa (?task ?solutions)
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (best-match (role-value ?task has-observables)
                                          ?sol
                                          (role-value ?task has-solution-space)
                                          (role-value ?task 
                                                      has-match-criterion))))))))

(def-class  heuristic-match-psm (primitive-method) ?psm
  "This method simple iterates over all candidates, classifying
   the observables with respect to each candidate and then 
   returning the best explaining classes with respect to the criterion"
  ((has-input-role :value has-solution-space
                   :value has-observables
                   :value has-match-criterion)
   (has-output-role :value best-matching-solutions)
   (has-solution-space :type solution-space)
   (has-observables :type observables)
   (has-match-criterion :type match-criterion
                        :default-value default-match-criterion)
   (best-matching-solutions :type solution-space)
   (has-postcondition  
    :value (kappa (?psm ?solutions)
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (best-match (role-value ?task has-observables)
                                          ?sol
                                          (role-value ?task has-solution-space)
                                          (role-value ?task has-match-criterion))))))
   (has-body 
    :value '(lambda (?psm) 
              (heuristic-match-procedure (role-value ?psm has-observables)
                                         (role-value ?psm has-solution-space)
                                         (role-value ?psm has-match-criterion)))))
  :own-slots ((tackles-task-type 'heuristic-match)))




(def-procedure  heuristic-match-procedure (?obs ?solutions ?criterion)
  :lisp-fun #'(lambda (obs solutions criterion)
                (do-heuristic-match obs solutions criterion)))

(defun do-heuristic-match (obs candidates criterion)
  (let ((rel (findany '?rel `(has-match-score-comparison-relation 
                              ',criterion '?rel))))
    (when candidates
      (let ((best-score (ocml-eval-gen `(apply-match-criterion 
                                         ',criterion ',obs ',(car candidates))))
            (best-candidates (list (car candidates))))
        (dolist (c (cdr candidates))
          (let* ((c-score (ocml-eval-gen `(apply-match-criterion 
                                           ',criterion ',obs ',c)))
                 (winner (ocml-eval-gen `(the-better-match-score 
                                          ',best-score ',c-score ',criterion))))
            (cond ((equal winner :equal)
                   (push c best-candidates))
                  ((equal winner c-score)
                   (setf best-score c-score)
                   (setf best-candidates (List c))))))
        best-candidates))))



;;;;;;;;;;REFINEMENT TASK;;;;;;;;;;;;;;;;;;;;;;;;;


;;;CLASS REFINER
(def-class refiner (function) 
  ((domain :value solution)
   (range :value solution-space)
   (applicability-condition :type refiner-applicability-condition-class)))

(def-class refiner-applicability-condition-class (unary-relation) ?x
  "The applicability condition for a refiner must be a relation whose domain is 
    a subset of class solution"
  :iff-def (subset ?x solution))

(def-relation refiner-is-applicable? (?ref ?solution)
  :constraint (and (solution ?solution)
                   (refiner ?ref))
  :iff-def (holds (the ?appl (applicability-condition ?ref ?appl)) ?solution))

(def-relation some-refiner-is-applicable? (?refs ?solution)
  :constraint (and (solution ?solution)
                   (list ?refs))
  :iff-def (exists ?ref (and (member ?ref ?refs)
                             (refiner-is-applicable? ?ref ?solution))))

;;;FUNCTION APPLY-REFINER-OPERATOR
(def-function apply-refiner-operator (?ref ?solution) -> ?sols
  :constraint (and (solution-space ?sols)
                   (refiner ?ref)
                   (solution ?solution)
                   )
  :body (if (refiner-is-applicable? ?ref ?solution)
          (call (the ?body (has-body ?ref ?body))
                ?solution)))


;;;GENERALISED-REFINEMENT-OF
(def-relation generalised-refinement-of (?sol-out ?sol-in ?refs)
  :iff-def (or (exists ?ref (and (member ?ref ?refs)
                                 (member ?sol-out 
                                         (apply-refiner-operator ?ref ?sol-in))))
               (exists ?sol-temp
                       (and (generalised-refinement-of ?sol-temp ?sol-in ?refs)
                            (generalised-refinement-of ?sol-out ?sol-temp ?refs)))))



;;;REFINEMENT-THROUGH-SUBCLASS-OF-LINKS
(def-instance refinement-through-subclass-of-links refiner
  "If the solution space is specified by means of classes arranged in a subclass-of
   hierarchy, then this is a good refiner to use"
  ((has-body '(lambda (?sol)
                (setofall ?sub (direct-subclass-of ?sub ?sol))))
   (applicability-condition (kappa (?sol)
                                   (and (class ?sol)
                                        (exists ?sub 
                                                (direct-subclass-of ?sub ?sol)))))))
;;;TASK REFINEMENT
(def-class refinement (goal-specification-task) ?task
  "The goal of this task is to take the current set of best solutions at a given level 
   of refinement, say n, and to try refine each of them in turn, using the given set of 
   refiners. All refiners are tried for each solution at level n, but the refinement 
   hierarchy is navigated down 1 level only.  That is, the output will include 
   at most solutions at level n+1.
   If a solution at level n cannot be refined, this will be also part of the output.  
   That is, the output includes all the new solutions of level n+1, plus all 
   the 'old solutions' for which no refiner is applicable"
  ((has-input-role :value has-basic-solutions
                   :value has-observables
                   :value has-refiners)
   (has-output-role :value has-refined-solutions)
   (has-basic-solutions :type solution-space)
   (has-observables :type observables)
   (has-refined-solutions :type solution-space)
   (has-refiners :type list)
   (has-goal-expression
    :value (kappa (?task ?solutions)
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (or (and (member 
                                        ?sol (role-value ?task 'has-basic-solutions))
                                       (not (some-refiner-is-applicable? 
                                             (role-value ?task has-refiners)?sol)))
                                  (and (not (member 
                                             ?sol (role-value 
                                                   ?task 
                                                   'has-basic-solutions)))
                                       (exists (?sol2 ?ref)
                                               (member ?sol2 
                                                       (role-value 
                                                        ?task 
                                                        'has-basic-solutions))
                                               (member ?ref
                                                       (role-value
                                                        ?task has-refiners))
                                               (not (member ?sol2 ?solutions))
                                               (member 
                                                ?sol (apply-refiner-operator 
                                                      ?ref ?sol2)))))))))))


(def-relation most-specific-solution (?solution ?refiners)
  :iff-def (not (exists (?refiner)
                        (and  (member ?refiner ?refiners) 
                              (refiner-is-applicable? ?refiner ?solution)))))


;;;METHOD REFINEMENT-PSM
(def-class refinement-psm (decomposition-method) ?psm
  "This method applies refiners to the given set of solutions repeatedly 
  until no refinement can be executed and returns the set of most specific solutions"
  
  ((has-control-role :value has-current-refined-solutions)
   (has-current-refined-solutions :type solution-space)
   (has-assumption 
    :value (kappa (?psm)
                  (forall (?sol-out ?sol-in ?ref)
                          (=> (and (member ?sol-out 
                                           (role-value ?psm 'has-refined-solutions))
                                   (member ?sol-in 
                                           (role-value ?psm 'has-basic-solutions))
                                   (member ?ref (role-value ?psm 'has-refiners))
                                   (member ?sol-out (apply-refiner-operator 
                                                     ?ref 
                                                     ?sol-in)))
                              (better-match-than ?sol-out ?sol-in 
                                                 (role-value ?psm 'has-observables)
                                                 (role-value ?psm 
                                                             'has-match-criterion)))))
    :documentation "Refinement does not make things worse")
   
   (has-body :value 
             '(lambda (?psm)
                (do 
                  (set-role-value ?psm 'has-current-refined-solutions nil)
                  (loop for ?sol in (role-value ?psm 'has-basic-solutions)
                        do
                        (in-environment 
                         ((?refs . (achieve-generic-subtask 
                                    ?psm collect-refiners 
                                    has-solution ?sol
                                    has-refiners (role-value ?psm has-refiners)))
                          (?new-sols . (achieve-generic-subtask 
                                        ?psm apply-refiners 
                                        has-solution ?sol
                                        has-refiners ?refs)))
                         (if (= ?new-sols nil)
                           (set-role-value 
                            ?psm 'has-current-refined-solutions 
                            (cons ?sol 
                                  (role-value ?psm 'has-current-refined-solutions)))
                           (set-role-value 
                            ?psm 'has-current-refined-solutions 
                            (append ?new-sols 
                                    (role-value 
                                     ?psm 
                                     'has-current-refined-solutions))))))
                  (role-value ?psm 'has-current-refined-solutions)))))
  :own-slots ((has-generic-subtasks '(apply-refiners collect-refiners))
              (tackles-task-type 'refinement)))

(def-class cautious-refinement-psm (decomposition-method) ?psm
  "This method applies refiners to the given set of solutions repeatedly 
  until no refinement can be executed and returns the set of most specific solutions.
  This method is cautious, in the sense that it does not assume that a refiner 
  necessarily produces a better solution.  Therefore, it will test the refined 
  solutions to check that they are indeed an improvement over their 'parent solution'."
  
  ((has-control-role :value has-current-refined-solutions)
   (has-current-refined-solutions :type solution-space)
   (has-postcondition 
    :value (kappa (?psm ?solutions)
                  (forall (?sol-out ?sol-in ?ref)
                          (=> (and (member ?sol-out ?solutions)
                                   (member ?sol-in (role-value 
                                                    ?psm 'has-basic-solutions))
                                   (member ?ref (role-value ?psm 'has-refiners))
                                   (member ?sol-out (apply-refiner-operator 
                                                     ?ref 
                                                     ?sol-in)))
                              (better-match-than ?sol-out ?sol-in 
                                                 (role-value 
                                                  ?psm 'has-observables)
                                                 (role-value 
                                                  ?psm 'has-match-criterion)))))
    :documentation "Our PSM ensures that refinement does not make things worse")
   
   (has-body :value 
             '(lambda (?psm)
                (do 
                  (set-role-value ?psm 'has-current-refined-solutions nil)
                  (loop for ?sol in (role-value ?psm 'has-basic-solutions)
                        do
                        (in-environment 
                         ((?refs . (achieve-generic-subtask 
                                    ?psm collect-refiners 
                                    has-solution ?sol
                                    has-refiners (role-value ?psm has-refiners)))
                          (?new-sols . (achieve-generic-subtask ?psm apply-refiners 
                                                                has-solution ?sol
                                                                has-refiners ?refs)))
                         (if (= ?new-sols nil)
                           (set-role-value 
                            ?psm 'has-current-refined-solutions 
                            (cons ?sol 
                                  (role-value ?psm 'has-current-refined-solutions)))
                           (set-role-value 
                            ?psm 'has-current-refined-solutions 
                            (append (achieve-generic-subtask 
                                     ?psm heuristic-match
                                     'has-observables (role-value 
                                                       ?psm 'has-observables)
                                     'has-solution-space  (cons ?sol ?new-sols)
                                     'has-match-criterion (role-value 
                                                           ?psm has-match-criterion))
                                    (role-value ?psm 
                                                'has-current-refined-solutions))))))
                  (role-value ?psm 'has-current-refined-solutions)))))
  :own-slots ((has-generic-subtasks '(apply-refiners collect-refiners))
              (tackles-task-type 'refinement)))




(def-class select-solution (goal-specification-task) ?task
  ((has-input-role :value has-solutions)
   (has-output-role :value has-selected-solution)
   (has-solutions :type solution-space)
   (has-selected-solution  :type solution)
   (has-goal-expression 
    :value (kappa (?task ?solution)
                  (member ?solution (role-value ?task has-solutions))))))


(def-class random-select-solution-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm) 
                       (the ?x (member ?x (role-value ?psm has-solutions))))))
  :own-slots ((tackles-task-type 'select-solution)))



(def-class  collect-refiners (goal-specification-task) ?task
  ((has-input-role :value has-solution
                   :value has-refiners)
   (has-output-role :value has-applicable-refiners)
   (has-solution :type solution)
   (has-refiners :type list)
   (has-applicable-refiners :type list)
   (has-goal-expression 
    :value (kappa (?task ?refiners)
                  (and (subset ?refiners (role-value ?task has-refiners))
                       (not (exists (?ref)
                                    (and (member ?ref ?refiners)
                                         (not (refiner-is-applicable? 
                                               ?ref (role-value 
                                                     ?task has-solution)))))))))))

(def-class standard-collect-refiners-psm (primitive-method) ?psm
  ((has-body :value '(lambda (?psm)
                       (setofall ?x (and (member ?x (role-value ?psm has-refiners))
                                         (refiner-is-applicable? 
                                          ?x (role-value ?psm has-solution)))))))
  
  :own-slots ((tackles-task-type 'collect-refiners)))


;;;TASK APPLY-REFINERS
(def-class  apply-refiners (goal-specification-task) ?task
  "The goal of this task is to generate all possible refinement of a solution, given
   a set of refiners.  Only one-step refinement is carried out here.  That is, if the 
   input solution is defined at level n, the output can only be at level n+1."
  ((has-input-role :value has-solution
                   :value has-refiners)
   (has-output-role :value has-refined-solutions)
   (has-solution :type solution)
   (has-refiners :type list)
   (has-refined-solutions :type solution-space)
   (has-goal-expression 
    :value (kappa (?task ?solutions) 
                  (forall ?sol
                          (=> (member ?sol ?solutions)
                              (exists ?ref 
                                      (and (member ?ref (role-value ?task 
                                                                    'has-refiners)
                                                   (member ?sol 
                                                           (apply-refiner-operator 
                                                            ?ref 
                                                            (role-value 
                                                             ?task 
                                                             'has-solution))))))))))))

;;;METHOD APPLY-REFINERS-PSM
(def-class apply-refiners-psm (primitive-method) ?psm
  ((has-control-role :value has-current-solutions)
   (has-current-solutions :type solution-space)
   (has-precondition :value (kappa (?psm)
                                   (every (role-value ?psm 'has-refiners)
                                          (kappa (?x)
                                                 (refiner-is-applicable? 
                                                  ?x 
                                                  (role-value ?psm has-solution))))))
   
   
   (has-body :value 
             '(lambda (?psm)
                (do
                  (set-role-value ?psm 'has-current-solutions nil)
                  (loop for ?ref in (role-value ?psm has-refiners)
                        do
                        (in-environment
                         ((?sols . (apply-refiner-operator
                                    ?ref 
                                    (role-value ?psm 'has-solution))))
                         (set-role-value ?psm 'has-current-solutions 
                                         (union (role-value ?psm 
                                                            'has-current-solutions)
                                                ?sols))))
                  (role-value ?psm 
                              'has-current-solutions)))))
  
  :own-slots ((tackles-task-type 'apply-refiners)
              ))


;;;;;;;;;;;;;;;;;;;;;;;;;

(defun heuristic-classify (&key solution-space observables abstractors refiners 
                                domain-name
                                (match-criterion 'default-match-criterion)
                                (method-type 'heuristic-classification-psm))
  
  
  
  (let* ((task (define-domain-instance 
                 (gentemp "CLASSIFICATION-TASK")
                 'classification-task
                 ""
                 `((has-solution-space ,solution-space)
                   (has-observables ,observables)
                   (has-match-criterion ,match-criterion))))
         
         (method (define-domain-instance 
                   (gentemp "METHOD")
                   method-type
                   ""
                   `((has-abstractors ,abstractors)
                     (has-refiners ,refiners))))
         (application (define-domain-instance 
                        (gentemp "CLASSIFICATION-APPLICATION")
                        'application
                        ""
                        `((tackles-domain ,domain-name)
                          (uses-method ,(name method))
                          (tackles-task ,(name task))))))
    (ocml-eval-gen `(solve-application ,(name application)))))